#
# Autogenerated by Thrift Compiler (1.0.0-dev)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
import sys
import common.ttypes

from thrift.transport import TTransport


class PacketHeader(object):
    """
    common RIFT packet header

    Attributes:
     - major_version
     - minor_version
     - sender: this is the node sending the packet, in case of LIE/TIRE/TIDE
    also the originator of it
     - level: level of the node sending the packet, required on everything except
    LIEs. Lack of presence on LIEs indicates UNDEFINED_LEVEL and is used
    in ZTP procedures.
    """

    thrift_spec = (
        None,  # 0
        (1, TType.BYTE, 'major_version', None, 1, ),  # 1
        (2, TType.BYTE, 'minor_version', None, 0, ),  # 2
        (3, TType.I64, 'sender', None, None, ),  # 3
        (4, TType.BYTE, 'level', None, None, ),  # 4
    )

    def __init__(self, major_version=thrift_spec[1][4], minor_version=thrift_spec[2][4], sender=None, level=None,):
        if major_version is self.thrift_spec[1][4]:
            major_version = 1
        self.major_version = major_version
        if minor_version is self.thrift_spec[2][4]:
            minor_version = 0
        self.minor_version = minor_version
        self.sender = sender
        self.level = level

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.major_version = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.minor_version = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.sender = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BYTE:
                    self.level = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('PacketHeader')
        if self.major_version is not None:
            oprot.writeFieldBegin('major_version', TType.BYTE, 1)
            oprot.writeByte(self.major_version)
            oprot.writeFieldEnd()
        if self.minor_version is not None:
            oprot.writeFieldBegin('minor_version', TType.BYTE, 2)
            oprot.writeByte(self.minor_version)
            oprot.writeFieldEnd()
        if self.sender is not None:
            oprot.writeFieldBegin('sender', TType.I64, 3)
            oprot.writeI64(self.sender)
            oprot.writeFieldEnd()
        if self.level is not None:
            oprot.writeFieldBegin('level', TType.BYTE, 4)
            oprot.writeByte(self.level)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.major_version is None:
            raise TProtocolException(message='Required field major_version is unset!')
        if self.minor_version is None:
            raise TProtocolException(message='Required field minor_version is unset!')
        if self.sender is None:
            raise TProtocolException(message='Required field sender is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Community(object):
    """
    Community serves as community for PGP purposes

    Attributes:
     - top
     - bottom
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'top', None, None, ),  # 1
        (2, TType.I32, 'bottom', None, None, ),  # 2
    )

    def __init__(self, top=None, bottom=None,):
        self.top = top
        self.bottom = bottom

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.top = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.bottom = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('Community')
        if self.top is not None:
            oprot.writeFieldBegin('top', TType.I32, 1)
            oprot.writeI32(self.top)
            oprot.writeFieldEnd()
        if self.bottom is not None:
            oprot.writeFieldBegin('bottom', TType.I32, 2)
            oprot.writeI32(self.bottom)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.top is None:
            raise TProtocolException(message='Required field top is unset!')
        if self.bottom is None:
            raise TProtocolException(message='Required field bottom is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Neighbor(object):
    """
    Neighbor structure

    Attributes:
     - originator
     - remote_id
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'originator', None, None, ),  # 1
        (2, TType.I32, 'remote_id', None, None, ),  # 2
    )

    def __init__(self, originator=None, remote_id=None,):
        self.originator = originator
        self.remote_id = remote_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.originator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.remote_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('Neighbor')
        if self.originator is not None:
            oprot.writeFieldBegin('originator', TType.I64, 1)
            oprot.writeI64(self.originator)
            oprot.writeFieldEnd()
        if self.remote_id is not None:
            oprot.writeFieldBegin('remote_id', TType.I32, 2)
            oprot.writeI32(self.remote_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.originator is None:
            raise TProtocolException(message='Required field originator is unset!')
        if self.remote_id is None:
            raise TProtocolException(message='Required field remote_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeCapabilities(object):
    """
    Capabilities the node supports. The schema may add to this
    field future capabilities to indicate whether it will support
    interpretation of future schema extensions on the same major
    revision. Such fields MUST be optional and have an implicit or
    explicit false default value. If a future capability changes route
    selection or generates blackholes if some nodes are not supporting
    it then a major version increment is unavoidable.

    Attributes:
     - flood_reduction: can this node participate in flood reduction
     - hierarchy_indications: does this node restrict itself to be top-of-fabric or
    leaf only (in ZTP) and does it support leaf-2-leaf procedures
    """

    thrift_spec = (
        None,  # 0
        (1, TType.BOOL, 'flood_reduction', None, True, ),  # 1
        (2, TType.I32, 'hierarchy_indications', None, None, ),  # 2
    )

    def __init__(self, flood_reduction=thrift_spec[1][4], hierarchy_indications=None,):
        self.flood_reduction = flood_reduction
        self.hierarchy_indications = hierarchy_indications

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.flood_reduction = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.hierarchy_indications = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('NodeCapabilities')
        if self.flood_reduction is not None:
            oprot.writeFieldBegin('flood_reduction', TType.BOOL, 1)
            oprot.writeBool(self.flood_reduction)
            oprot.writeFieldEnd()
        if self.hierarchy_indications is not None:
            oprot.writeFieldBegin('hierarchy_indications', TType.I32, 2)
            oprot.writeI32(self.hierarchy_indications)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LinkCapabilities(object):
    """
    Attributes:
     - bfd
    """

    thrift_spec = (
        None,  # 0
        (1, TType.BOOL, 'bfd', None, True, ),  # 1
    )

    def __init__(self, bfd=thrift_spec[1][4],):
        self.bfd = bfd

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.bfd = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('LinkCapabilities')
        if self.bfd is not None:
            oprot.writeFieldBegin('bfd', TType.BOOL, 1)
            oprot.writeBool(self.bfd)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LIEPacket(object):
    """
    RIFT LIE packet

    @note this node's level is already included on the packet header

    Attributes:
     - name: optional node or adjacency name
     - local_id: local link ID
     - flood_port: UDP port to which we can receive flooded TIEs
     - link_mtu_size: layer 3 MTU, used to discover to mismatch.
     - link_bandwidth: local link bandwidth on the interface
     - neighbor: this will reflect the neighbor once received to provide
    3-way connectivity
     - pod
     - node_capabilities: optional node capabilities shown in the LIE. The capabilies
    MUST match the capabilities shown in the Node TIEs, otherwise
    the behavior is unspecified. A node detecting the mismatch
    SHOULD generate according error
     - link_capabilities
     - holdtime: required holdtime of the adjacency, i.e. how much time
    MUST expire without LIE for the adjacency to drop
     - label: optional downstream assigned locally significant label
    value for the adjacency
     - not_a_ztp_offer: indicates that the level on the LIE MUST NOT be used
    to derive a ZTP level by the receiving node
     - you_are_flood_repeater: indicates to northbound neighbor that it should
    be reflooding this node's N-TIEs to achieve flood reduction and
    balancing for northbound flooding. To be ignored if received from a
    northbound adjacency
     - you_are_sending_too_quickly: can be optionally set to indicate to neighbor that packet losses are seen on
    reception based on packet numbers or the rate is too high. The receiver SHOULD
    temporarily slow down flooding rates.
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
        (2, TType.I32, 'local_id', None, None, ),  # 2
        (3, TType.I16, 'flood_port', None, 912, ),  # 3
        (4, TType.I32, 'link_mtu_size', None, 1400, ),  # 4
        (5, TType.I32, 'link_bandwidth', None, 100, ),  # 5
        (6, TType.STRUCT, 'neighbor', (Neighbor, Neighbor.thrift_spec), None, ),  # 6
        (7, TType.I32, 'pod', None, 0, ),  # 7
        None,  # 8
        None,  # 9
        (10, TType.STRUCT, 'node_capabilities', (NodeCapabilities, NodeCapabilities.thrift_spec), None, ),  # 10
        (11, TType.STRUCT, 'link_capabilities', (LinkCapabilities, LinkCapabilities.thrift_spec), None, ),  # 11
        (12, TType.I16, 'holdtime', None, 3, ),  # 12
        (13, TType.I32, 'label', None, None, ),  # 13
        None,  # 14
        None,  # 15
        None,  # 16
        None,  # 17
        None,  # 18
        None,  # 19
        None,  # 20
        (21, TType.BOOL, 'not_a_ztp_offer', None, False, ),  # 21
        (22, TType.BOOL, 'you_are_flood_repeater', None, True, ),  # 22
        (23, TType.BOOL, 'you_are_sending_too_quickly', None, False, ),  # 23
    )

    def __init__(self, name=None, local_id=None, flood_port=thrift_spec[3][4], link_mtu_size=thrift_spec[4][4], link_bandwidth=thrift_spec[5][4], neighbor=None, pod=thrift_spec[7][4], node_capabilities=None, link_capabilities=None, holdtime=thrift_spec[12][4], label=None, not_a_ztp_offer=thrift_spec[21][4], you_are_flood_repeater=thrift_spec[22][4], you_are_sending_too_quickly=thrift_spec[23][4],):
        self.name = name
        self.local_id = local_id
        if flood_port is self.thrift_spec[3][4]:
            flood_port = 912
        self.flood_port = flood_port
        if link_mtu_size is self.thrift_spec[4][4]:
            link_mtu_size = 1400
        self.link_mtu_size = link_mtu_size
        if link_bandwidth is self.thrift_spec[5][4]:
            link_bandwidth = 100
        self.link_bandwidth = link_bandwidth
        self.neighbor = neighbor
        if pod is self.thrift_spec[7][4]:
            pod = 0
        self.pod = pod
        self.node_capabilities = node_capabilities
        self.link_capabilities = link_capabilities
        if holdtime is self.thrift_spec[12][4]:
            holdtime = 3
        self.holdtime = holdtime
        self.label = label
        self.not_a_ztp_offer = not_a_ztp_offer
        self.you_are_flood_repeater = you_are_flood_repeater
        self.you_are_sending_too_quickly = you_are_sending_too_quickly

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.local_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.flood_port = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.link_mtu_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.link_bandwidth = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.neighbor = Neighbor()
                    self.neighbor.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.pod = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.node_capabilities = NodeCapabilities()
                    self.node_capabilities.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.link_capabilities = LinkCapabilities()
                    self.link_capabilities.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I16:
                    self.holdtime = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.label = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.BOOL:
                    self.not_a_ztp_offer = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.BOOL:
                    self.you_are_flood_repeater = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.BOOL:
                    self.you_are_sending_too_quickly = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('LIEPacket')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.local_id is not None:
            oprot.writeFieldBegin('local_id', TType.I32, 2)
            oprot.writeI32(self.local_id)
            oprot.writeFieldEnd()
        if self.flood_port is not None:
            oprot.writeFieldBegin('flood_port', TType.I16, 3)
            oprot.writeI16(self.flood_port)
            oprot.writeFieldEnd()
        if self.link_mtu_size is not None:
            oprot.writeFieldBegin('link_mtu_size', TType.I32, 4)
            oprot.writeI32(self.link_mtu_size)
            oprot.writeFieldEnd()
        if self.link_bandwidth is not None:
            oprot.writeFieldBegin('link_bandwidth', TType.I32, 5)
            oprot.writeI32(self.link_bandwidth)
            oprot.writeFieldEnd()
        if self.neighbor is not None:
            oprot.writeFieldBegin('neighbor', TType.STRUCT, 6)
            self.neighbor.write(oprot)
            oprot.writeFieldEnd()
        if self.pod is not None:
            oprot.writeFieldBegin('pod', TType.I32, 7)
            oprot.writeI32(self.pod)
            oprot.writeFieldEnd()
        if self.node_capabilities is not None:
            oprot.writeFieldBegin('node_capabilities', TType.STRUCT, 10)
            self.node_capabilities.write(oprot)
            oprot.writeFieldEnd()
        if self.link_capabilities is not None:
            oprot.writeFieldBegin('link_capabilities', TType.STRUCT, 11)
            self.link_capabilities.write(oprot)
            oprot.writeFieldEnd()
        if self.holdtime is not None:
            oprot.writeFieldBegin('holdtime', TType.I16, 12)
            oprot.writeI16(self.holdtime)
            oprot.writeFieldEnd()
        if self.label is not None:
            oprot.writeFieldBegin('label', TType.I32, 13)
            oprot.writeI32(self.label)
            oprot.writeFieldEnd()
        if self.not_a_ztp_offer is not None:
            oprot.writeFieldBegin('not_a_ztp_offer', TType.BOOL, 21)
            oprot.writeBool(self.not_a_ztp_offer)
            oprot.writeFieldEnd()
        if self.you_are_flood_repeater is not None:
            oprot.writeFieldBegin('you_are_flood_repeater', TType.BOOL, 22)
            oprot.writeBool(self.you_are_flood_repeater)
            oprot.writeFieldEnd()
        if self.you_are_sending_too_quickly is not None:
            oprot.writeFieldBegin('you_are_sending_too_quickly', TType.BOOL, 23)
            oprot.writeBool(self.you_are_sending_too_quickly)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.local_id is None:
            raise TProtocolException(message='Required field local_id is unset!')
        if self.flood_port is None:
            raise TProtocolException(message='Required field flood_port is unset!')
        if self.holdtime is None:
            raise TProtocolException(message='Required field holdtime is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LinkIDPair(object):
    """
    LinkID pair describes one of parallel links between two nodes

    Attributes:
     - local_id: node-wide unique value for the local link
     - remote_id: received remote link ID for this link
     - platform_interface_index: optionally describes the local interface index of the link
     - platform_interface_name: optionally describes the local interface name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'local_id', None, None, ),  # 1
        (2, TType.I32, 'remote_id', None, None, ),  # 2
        None,  # 3
        None,  # 4
        None,  # 5
        None,  # 6
        None,  # 7
        None,  # 8
        None,  # 9
        (10, TType.I32, 'platform_interface_index', None, None, ),  # 10
        (11, TType.STRING, 'platform_interface_name', 'UTF8', None, ),  # 11
    )

    def __init__(self, local_id=None, remote_id=None, platform_interface_index=None, platform_interface_name=None,):
        self.local_id = local_id
        self.remote_id = remote_id
        self.platform_interface_index = platform_interface_index
        self.platform_interface_name = platform_interface_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.local_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.remote_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.platform_interface_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.platform_interface_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('LinkIDPair')
        if self.local_id is not None:
            oprot.writeFieldBegin('local_id', TType.I32, 1)
            oprot.writeI32(self.local_id)
            oprot.writeFieldEnd()
        if self.remote_id is not None:
            oprot.writeFieldBegin('remote_id', TType.I32, 2)
            oprot.writeI32(self.remote_id)
            oprot.writeFieldEnd()
        if self.platform_interface_index is not None:
            oprot.writeFieldBegin('platform_interface_index', TType.I32, 10)
            oprot.writeI32(self.platform_interface_index)
            oprot.writeFieldEnd()
        if self.platform_interface_name is not None:
            oprot.writeFieldBegin('platform_interface_name', TType.STRING, 11)
            oprot.writeString(self.platform_interface_name.encode('utf-8') if sys.version_info[0] == 2 else self.platform_interface_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.local_id is None:
            raise TProtocolException(message='Required field local_id is unset!')
        if self.remote_id is None:
            raise TProtocolException(message='Required field remote_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIEID(object):
    """
    ID of a TIE

    @note: TIEID space is a total order achieved by comparing the elements
           in sequence defined and comparing each value as an
           unsigned integer of according length.

    Attributes:
     - direction: indicates direction of the TIE
     - originator: indicates originator of the TIE
     - tietype
     - tie_nr
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'direction', None, None, ),  # 1
        (2, TType.I64, 'originator', None, None, ),  # 2
        (3, TType.I32, 'tietype', None, None, ),  # 3
        (4, TType.I32, 'tie_nr', None, None, ),  # 4
    )

    def __init__(self, direction=None, originator=None, tietype=None, tie_nr=None,):
        self.direction = direction
        self.originator = originator
        self.tietype = tietype
        self.tie_nr = tie_nr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.originator = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.tietype = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.tie_nr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TIEID')
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.I32, 1)
            oprot.writeI32(self.direction)
            oprot.writeFieldEnd()
        if self.originator is not None:
            oprot.writeFieldBegin('originator', TType.I64, 2)
            oprot.writeI64(self.originator)
            oprot.writeFieldEnd()
        if self.tietype is not None:
            oprot.writeFieldBegin('tietype', TType.I32, 3)
            oprot.writeI32(self.tietype)
            oprot.writeFieldEnd()
        if self.tie_nr is not None:
            oprot.writeFieldBegin('tie_nr', TType.I32, 4)
            oprot.writeI32(self.tie_nr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.direction is None:
            raise TProtocolException(message='Required field direction is unset!')
        if self.originator is None:
            raise TProtocolException(message='Required field originator is unset!')
        if self.tietype is None:
            raise TProtocolException(message='Required field tietype is unset!')
        if self.tie_nr is None:
            raise TProtocolException(message='Required field tie_nr is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIEHeader(object):
    """
    Header of a TIE.

    @note: TIEID space is a total order achieved by comparing the elements
               in sequence defined and comparing each value as an
               unsigned integer of according length.

               After sequence number the lifetime received on the envelope
               must be used for comparison before further fields.

               `origination_time` and `origination_lifetime` are disregarded
               for comparison purposes and carried purely for debugging/security
               purposes if present.

    Attributes:
     - tieid
     - seq_nr
     - origination_time: optional absolute timestamp when the TIE
    was generated. This can be used on fabrics with
    synchronized clock to prevent lifetime modification attacks.
     - origination_lifetime: optional original lifetime when the TIE
    was generated. This can be used on fabrics with
    synchronized clock to prevent lifetime modification attacks.
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.STRUCT, 'tieid', (TIEID, TIEID.thrift_spec), None, ),  # 2
        (3, TType.I16, 'seq_nr', None, None, ),  # 3
        None,  # 4
        None,  # 5
        None,  # 6
        None,  # 7
        None,  # 8
        None,  # 9
        (10, TType.STRUCT, 'origination_time', (common.ttypes.IEEE802_1ASTimeStampType, common.ttypes.IEEE802_1ASTimeStampType.thrift_spec), None, ),  # 10
        None,  # 11
        (12, TType.I32, 'origination_lifetime', None, None, ),  # 12
    )

    def __init__(self, tieid=None, seq_nr=None, origination_time=None, origination_lifetime=None,):
        self.tieid = tieid
        self.seq_nr = seq_nr
        self.origination_time = origination_time
        self.origination_lifetime = origination_lifetime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.tieid = TIEID()
                    self.tieid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.seq_nr = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.origination_time = common.ttypes.IEEE802_1ASTimeStampType()
                    self.origination_time.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.origination_lifetime = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TIEHeader')
        if self.tieid is not None:
            oprot.writeFieldBegin('tieid', TType.STRUCT, 2)
            self.tieid.write(oprot)
            oprot.writeFieldEnd()
        if self.seq_nr is not None:
            oprot.writeFieldBegin('seq_nr', TType.I16, 3)
            oprot.writeI16(self.seq_nr)
            oprot.writeFieldEnd()
        if self.origination_time is not None:
            oprot.writeFieldBegin('origination_time', TType.STRUCT, 10)
            self.origination_time.write(oprot)
            oprot.writeFieldEnd()
        if self.origination_lifetime is not None:
            oprot.writeFieldBegin('origination_lifetime', TType.I32, 12)
            oprot.writeI32(self.origination_lifetime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tieid is None:
            raise TProtocolException(message='Required field tieid is unset!')
        if self.seq_nr is None:
            raise TProtocolException(message='Required field seq_nr is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIEHeaderWithLifeTime(object):
    """
    Header of a TIE as described in TIRE/TIDE.

    Attributes:
     - header
     - remaining_lifetime: remaining lifetime that expires down to 0 just like in ISIS.
    TIEs with lifetimes differing by less than `lifetime_diff2ignore` MUST
    be considered EQUAL.
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'header', (TIEHeader, TIEHeader.thrift_spec), None, ),  # 1
        (2, TType.I32, 'remaining_lifetime', None, None, ),  # 2
    )

    def __init__(self, header=None, remaining_lifetime=None,):
        self.header = header
        self.remaining_lifetime = remaining_lifetime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = TIEHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.remaining_lifetime = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TIEHeaderWithLifeTime')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.remaining_lifetime is not None:
            oprot.writeFieldBegin('remaining_lifetime', TType.I32, 2)
            oprot.writeI32(self.remaining_lifetime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.header is None:
            raise TProtocolException(message='Required field header is unset!')
        if self.remaining_lifetime is None:
            raise TProtocolException(message='Required field remaining_lifetime is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIDEPacket(object):
    """
    A TIDE with sorted TIE headers, if headers unsorted, behavior is undefined

    Attributes:
     - start_range: all 00s marks starts
     - end_range: all FFs mark end
     - headers: _sorted_ list of headers
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'start_range', (TIEID, TIEID.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'end_range', (TIEID, TIEID.thrift_spec), None, ),  # 2
        (3, TType.LIST, 'headers', (TType.STRUCT, (TIEHeaderWithLifeTime, TIEHeaderWithLifeTime.thrift_spec), False), None, ),  # 3
    )

    def __init__(self, start_range=None, end_range=None, headers=None,):
        self.start_range = start_range
        self.end_range = end_range
        self.headers = headers

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.start_range = TIEID()
                    self.start_range.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.end_range = TIEID()
                    self.end_range.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.headers = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = TIEHeaderWithLifeTime()
                        _elem5.read(iprot)
                        self.headers.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TIDEPacket')
        if self.start_range is not None:
            oprot.writeFieldBegin('start_range', TType.STRUCT, 1)
            self.start_range.write(oprot)
            oprot.writeFieldEnd()
        if self.end_range is not None:
            oprot.writeFieldBegin('end_range', TType.STRUCT, 2)
            self.end_range.write(oprot)
            oprot.writeFieldEnd()
        if self.headers is not None:
            oprot.writeFieldBegin('headers', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.headers))
            for iter6 in self.headers:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.start_range is None:
            raise TProtocolException(message='Required field start_range is unset!')
        if self.end_range is None:
            raise TProtocolException(message='Required field end_range is unset!')
        if self.headers is None:
            raise TProtocolException(message='Required field headers is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIREPacket(object):
    """
    A TIRE packet

    Attributes:
     - headers
    """

    thrift_spec = (
        None,  # 0
        (1, TType.SET, 'headers', (TType.STRUCT, (TIEHeaderWithLifeTime, TIEHeaderWithLifeTime.thrift_spec), False), None, ),  # 1
    )

    def __init__(self, headers=None,):
        self.headers = headers

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.SET:
                    self.headers = set()
                    (_etype10, _size7) = iprot.readSetBegin()
                    for _i11 in range(_size7):
                        _elem12 = TIEHeaderWithLifeTime()
                        _elem12.read(iprot)
                        self.headers.add(_elem12)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TIREPacket')
        if self.headers is not None:
            oprot.writeFieldBegin('headers', TType.SET, 1)
            oprot.writeSetBegin(TType.STRUCT, len(self.headers))
            for iter13 in self.headers:
                iter13.write(oprot)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.headers is None:
            raise TProtocolException(message='Required field headers is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeNeighborsTIEElement(object):
    """
    Neighbor of a node

    Attributes:
     - level: Level of neighbor
     - cost: Cost to neighbor.

    @note: All parallel links to same node
    incur same cost, in case the neighbor has multiple
    parallel links at different cost, the largest distance
    (highest numerical value) MUST be advertised
    @note: any neighbor with cost <= 0 MUST be ignored in computations
     - link_ids: can carry description of multiple parallel links in a TIE
     - bandwidth: total bandwith to neighbor, this will be normally sum of the
    bandwidths of all the parallel links.
    """

    thrift_spec = (
        None,  # 0
        (1, TType.BYTE, 'level', None, None, ),  # 1
        None,  # 2
        (3, TType.I32, 'cost', None, 1, ),  # 3
        (4, TType.SET, 'link_ids', (TType.STRUCT, (LinkIDPair, LinkIDPair.thrift_spec), False), None, ),  # 4
        (5, TType.I32, 'bandwidth', None, 100, ),  # 5
    )

    def __init__(self, level=None, cost=thrift_spec[3][4], link_ids=None, bandwidth=thrift_spec[5][4],):
        self.level = level
        if cost is self.thrift_spec[3][4]:
            cost = 1
        self.cost = cost
        self.link_ids = link_ids
        if bandwidth is self.thrift_spec[5][4]:
            bandwidth = 100
        self.bandwidth = bandwidth

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.level = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.cost = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.link_ids = set()
                    (_etype17, _size14) = iprot.readSetBegin()
                    for _i18 in range(_size14):
                        _elem19 = LinkIDPair()
                        _elem19.read(iprot)
                        self.link_ids.add(_elem19)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.bandwidth = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('NodeNeighborsTIEElement')
        if self.level is not None:
            oprot.writeFieldBegin('level', TType.BYTE, 1)
            oprot.writeByte(self.level)
            oprot.writeFieldEnd()
        if self.cost is not None:
            oprot.writeFieldBegin('cost', TType.I32, 3)
            oprot.writeI32(self.cost)
            oprot.writeFieldEnd()
        if self.link_ids is not None:
            oprot.writeFieldBegin('link_ids', TType.SET, 4)
            oprot.writeSetBegin(TType.STRUCT, len(self.link_ids))
            for iter20 in self.link_ids:
                iter20.write(oprot)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.bandwidth is not None:
            oprot.writeFieldBegin('bandwidth', TType.I32, 5)
            oprot.writeI32(self.bandwidth)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.level is None:
            raise TProtocolException(message='Required field level is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeFlags(object):
    """
    Flags the node sets

    Attributes:
     - overload: node is in overload, do not transit traffic through it
    """

    thrift_spec = (
        None,  # 0
        (1, TType.BOOL, 'overload', None, False, ),  # 1
    )

    def __init__(self, overload=thrift_spec[1][4],):
        self.overload = overload

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.overload = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('NodeFlags')
        if self.overload is not None:
            oprot.writeFieldBegin('overload', TType.BOOL, 1)
            oprot.writeBool(self.overload)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeTIEElement(object):
    """
    Description of a node.

    It may occur multiple times in different TIEs but if either
        * capabilities values do not match or
        * flags values do not match or
        * neighbors repeat with different values

    the behavior is undefined and a warning SHOULD be generated.
    Neighbors can be distributed across multiple TIEs however if
    the sets are disjoint. Miscablings SHOULD be repeated in every
    node TIE, otherwise the behavior is undefined.

    @note: observe that absence of fields implies defined defaults

    Attributes:
     - level
     - neighbors: If neighbor systemID repeats in other node TIEs of same node
    the behavior is undefined.
     - capabilities
     - flags
     - name: optional node name for easier operations
     - pod: PoD to which the node belongs
     - miscabled_links: if any local links are miscabled, the indication is flooded.
    """

    thrift_spec = (
        None,  # 0
        (1, TType.BYTE, 'level', None, None, ),  # 1
        (2, TType.MAP, 'neighbors', (TType.I64, None, TType.STRUCT, (NodeNeighborsTIEElement, NodeNeighborsTIEElement.thrift_spec), False), None, ),  # 2
        (3, TType.STRUCT, 'capabilities', (NodeCapabilities, NodeCapabilities.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'flags', (NodeFlags, NodeFlags.thrift_spec), None, ),  # 4
        (5, TType.STRING, 'name', 'UTF8', None, ),  # 5
        (6, TType.I32, 'pod', None, None, ),  # 6
        None,  # 7
        None,  # 8
        None,  # 9
        (10, TType.SET, 'miscabled_links', (TType.I32, None, False), None, ),  # 10
    )

    def __init__(self, level=None, neighbors=None, capabilities=None, flags=None, name=None, pod=None, miscabled_links=None,):
        self.level = level
        self.neighbors = neighbors
        self.capabilities = capabilities
        self.flags = flags
        self.name = name
        self.pod = pod
        self.miscabled_links = miscabled_links

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.level = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.neighbors = {}
                    (_ktype22, _vtype23, _size21) = iprot.readMapBegin()
                    for _i25 in range(_size21):
                        _key26 = iprot.readI64()
                        _val27 = NodeNeighborsTIEElement()
                        _val27.read(iprot)
                        self.neighbors[_key26] = _val27
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.capabilities = NodeCapabilities()
                    self.capabilities.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.flags = NodeFlags()
                    self.flags.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.pod = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.SET:
                    self.miscabled_links = set()
                    (_etype31, _size28) = iprot.readSetBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readI32()
                        self.miscabled_links.add(_elem33)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('NodeTIEElement')
        if self.level is not None:
            oprot.writeFieldBegin('level', TType.BYTE, 1)
            oprot.writeByte(self.level)
            oprot.writeFieldEnd()
        if self.neighbors is not None:
            oprot.writeFieldBegin('neighbors', TType.MAP, 2)
            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.neighbors))
            for kiter34, viter35 in self.neighbors.items():
                oprot.writeI64(kiter34)
                viter35.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.capabilities is not None:
            oprot.writeFieldBegin('capabilities', TType.STRUCT, 3)
            self.capabilities.write(oprot)
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.STRUCT, 4)
            self.flags.write(oprot)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 5)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.pod is not None:
            oprot.writeFieldBegin('pod', TType.I32, 6)
            oprot.writeI32(self.pod)
            oprot.writeFieldEnd()
        if self.miscabled_links is not None:
            oprot.writeFieldBegin('miscabled_links', TType.SET, 10)
            oprot.writeSetBegin(TType.I32, len(self.miscabled_links))
            for iter36 in self.miscabled_links:
                oprot.writeI32(iter36)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.level is None:
            raise TProtocolException(message='Required field level is unset!')
        if self.neighbors is None:
            raise TProtocolException(message='Required field neighbors is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PrefixAttributes(object):
    """
    Attributes:
     - metric
     - tags: generic unordered set of route tags, can be redistributed to other protocols or use
    within the context of real time analytics
     - monotonic_clock: optional monotonic clock for mobile addresses
     - loopback: optionally indicates the interface is a node loopback
     - directly_attached: indicates that the prefix is directly attached, i.e. should be routed to even if
    the node is in overload. *
     - from_link: in case of locally originated prefixes, i.e. interface addresses this can
    describe which link the address belongs to.
    """

    thrift_spec = (
        None,  # 0
        None,  # 1
        (2, TType.I32, 'metric', None, 1, ),  # 2
        (3, TType.SET, 'tags', (TType.I64, None, False), None, ),  # 3
        (4, TType.STRUCT, 'monotonic_clock', (common.ttypes.PrefixSequenceType, common.ttypes.PrefixSequenceType.thrift_spec), None, ),  # 4
        None,  # 5
        (6, TType.BOOL, 'loopback', None, False, ),  # 6
        (7, TType.BOOL, 'directly_attached', None, True, ),  # 7
        None,  # 8
        None,  # 9
        (10, TType.I32, 'from_link', None, None, ),  # 10
    )

    def __init__(self, metric=thrift_spec[2][4], tags=None, monotonic_clock=None, loopback=thrift_spec[6][4], directly_attached=thrift_spec[7][4], from_link=None,):
        if metric is self.thrift_spec[2][4]:
            metric = 1
        self.metric = metric
        self.tags = tags
        self.monotonic_clock = monotonic_clock
        self.loopback = loopback
        self.directly_attached = directly_attached
        self.from_link = from_link

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.metric = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.tags = set()
                    (_etype40, _size37) = iprot.readSetBegin()
                    for _i41 in range(_size37):
                        _elem42 = iprot.readI64()
                        self.tags.add(_elem42)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.monotonic_clock = common.ttypes.PrefixSequenceType()
                    self.monotonic_clock.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.loopback = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.directly_attached = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.from_link = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('PrefixAttributes')
        if self.metric is not None:
            oprot.writeFieldBegin('metric', TType.I32, 2)
            oprot.writeI32(self.metric)
            oprot.writeFieldEnd()
        if self.tags is not None:
            oprot.writeFieldBegin('tags', TType.SET, 3)
            oprot.writeSetBegin(TType.I64, len(self.tags))
            for iter43 in self.tags:
                oprot.writeI64(iter43)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.monotonic_clock is not None:
            oprot.writeFieldBegin('monotonic_clock', TType.STRUCT, 4)
            self.monotonic_clock.write(oprot)
            oprot.writeFieldEnd()
        if self.loopback is not None:
            oprot.writeFieldBegin('loopback', TType.BOOL, 6)
            oprot.writeBool(self.loopback)
            oprot.writeFieldEnd()
        if self.directly_attached is not None:
            oprot.writeFieldBegin('directly_attached', TType.BOOL, 7)
            oprot.writeBool(self.directly_attached)
            oprot.writeFieldEnd()
        if self.from_link is not None:
            oprot.writeFieldBegin('from_link', TType.I32, 10)
            oprot.writeI32(self.from_link)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.metric is None:
            raise TProtocolException(message='Required field metric is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PrefixTIEElement(object):
    """
    multiple prefixes

    Attributes:
     - prefixes: prefixes with the associated attributes.
    if the same prefix repeats in multiple TIEs of same node
    behavior is unspecified
    """

    thrift_spec = (
        None,  # 0
        (1, TType.MAP, 'prefixes', (TType.STRUCT, (common.ttypes.IPPrefixType, common.ttypes.IPPrefixType.thrift_spec), TType.STRUCT, (PrefixAttributes, PrefixAttributes.thrift_spec), False), None, ),  # 1
    )

    def __init__(self, prefixes=None,):
        self.prefixes = prefixes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.prefixes = {}
                    (_ktype45, _vtype46, _size44) = iprot.readMapBegin()
                    for _i48 in range(_size44):
                        _key49 = common.ttypes.IPPrefixType()
                        _key49.read(iprot)
                        _val50 = PrefixAttributes()
                        _val50.read(iprot)
                        self.prefixes[_key49] = _val50
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('PrefixTIEElement')
        if self.prefixes is not None:
            oprot.writeFieldBegin('prefixes', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(self.prefixes))
            for kiter51, viter52 in self.prefixes.items():
                kiter51.write(oprot)
                viter52.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.prefixes is None:
            raise TProtocolException(message='Required field prefixes is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class KeyValueTIEElement(object):
    """
    keys with their values

    Attributes:
     - keyvalues: if the same key repeats in multiple TIEs of same node
    or with different values, behavior is unspecified
    """

    thrift_spec = (
        None,  # 0
        (1, TType.MAP, 'keyvalues', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    )

    def __init__(self, keyvalues=None,):
        self.keyvalues = keyvalues

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.keyvalues = {}
                    (_ktype54, _vtype55, _size53) = iprot.readMapBegin()
                    for _i57 in range(_size53):
                        _key58 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val59 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyvalues[_key58] = _val59
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('KeyValueTIEElement')
        if self.keyvalues is not None:
            oprot.writeFieldBegin('keyvalues', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.keyvalues))
            for kiter60, viter61 in self.keyvalues.items():
                oprot.writeString(kiter60.encode('utf-8') if sys.version_info[0] == 2 else kiter60)
                oprot.writeString(viter61.encode('utf-8') if sys.version_info[0] == 2 else viter61)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.keyvalues is None:
            raise TProtocolException(message='Required field keyvalues is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIEElement(object):
    """
    single element in a TIE. enum `common.TIETypeType`
    in TIEID indicates which elements MUST be present
    in the TIEElement. In case of mismatch the unexpected
    elements MUST be ignored. In case of lack of expected
    element the TIE an error MUST be reported and the TIE
    MUST be ignored.

    This type can be extended with new optional elements
    for new `common.TIETypeType` values without breaking
    the major but if it is necessary to understand whether
    all nodes support the new type a node capability must
    be added as well.

    Attributes:
     - node: in case of enum common.TIETypeType.NodeTIEType
     - prefixes: in case of enum common.TIETypeType.PrefixTIEType
     - positive_disaggregation_prefixes: positive prefixes (always southbound)
    It MUST NOT be advertised within a North TIE.
     - negative_disaggregation_prefixes: transitive, negative prefixes (always southbound) which
    MUST be aggregated and propagated
    according to the specification
    southwards towards lower levels to heal
    pathological upper level partitioning, otherwise
    blackholes may occur in multiplane fabrics.
    It MUST NOT be advertised within a North TIE.
     - external_prefixes: externally reimported prefixes
     - keyvalues: Key-Value store elements
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'node', (NodeTIEElement, NodeTIEElement.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'prefixes', (PrefixTIEElement, PrefixTIEElement.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'positive_disaggregation_prefixes', (PrefixTIEElement, PrefixTIEElement.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'negative_disaggregation_prefixes', (PrefixTIEElement, PrefixTIEElement.thrift_spec), None, ),  # 4
        (5, TType.STRUCT, 'external_prefixes', (PrefixTIEElement, PrefixTIEElement.thrift_spec), None, ),  # 5
        (6, TType.STRUCT, 'keyvalues', (KeyValueTIEElement, KeyValueTIEElement.thrift_spec), None, ),  # 6
    )

    def __init__(self, node=None, prefixes=None, positive_disaggregation_prefixes=None, negative_disaggregation_prefixes=None, external_prefixes=None, keyvalues=None,):
        self.node = node
        self.prefixes = prefixes
        self.positive_disaggregation_prefixes = positive_disaggregation_prefixes
        self.negative_disaggregation_prefixes = negative_disaggregation_prefixes
        self.external_prefixes = external_prefixes
        self.keyvalues = keyvalues

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.node = NodeTIEElement()
                    self.node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.prefixes = PrefixTIEElement()
                    self.prefixes.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.positive_disaggregation_prefixes = PrefixTIEElement()
                    self.positive_disaggregation_prefixes.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.negative_disaggregation_prefixes = PrefixTIEElement()
                    self.negative_disaggregation_prefixes.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.external_prefixes = PrefixTIEElement()
                    self.external_prefixes.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.keyvalues = KeyValueTIEElement()
                    self.keyvalues.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TIEElement')
        if self.node is not None:
            oprot.writeFieldBegin('node', TType.STRUCT, 1)
            self.node.write(oprot)
            oprot.writeFieldEnd()
        if self.prefixes is not None:
            oprot.writeFieldBegin('prefixes', TType.STRUCT, 2)
            self.prefixes.write(oprot)
            oprot.writeFieldEnd()
        if self.positive_disaggregation_prefixes is not None:
            oprot.writeFieldBegin('positive_disaggregation_prefixes', TType.STRUCT, 3)
            self.positive_disaggregation_prefixes.write(oprot)
            oprot.writeFieldEnd()
        if self.negative_disaggregation_prefixes is not None:
            oprot.writeFieldBegin('negative_disaggregation_prefixes', TType.STRUCT, 4)
            self.negative_disaggregation_prefixes.write(oprot)
            oprot.writeFieldEnd()
        if self.external_prefixes is not None:
            oprot.writeFieldBegin('external_prefixes', TType.STRUCT, 5)
            self.external_prefixes.write(oprot)
            oprot.writeFieldEnd()
        if self.keyvalues is not None:
            oprot.writeFieldBegin('keyvalues', TType.STRUCT, 6)
            self.keyvalues.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIEPacket(object):
    """
    @todo: policy guided prefixes

    Attributes:
     - header
     - element
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'header', (TIEHeader, TIEHeader.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'element', (TIEElement, TIEElement.thrift_spec), None, ),  # 2
    )

    def __init__(self, header=None, element=None,):
        self.header = header
        self.element = element

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = TIEHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.element = TIEElement()
                    self.element.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TIEPacket')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.element is not None:
            oprot.writeFieldBegin('element', TType.STRUCT, 2)
            self.element.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.header is None:
            raise TProtocolException(message='Required field header is unset!')
        if self.element is None:
            raise TProtocolException(message='Required field element is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PacketContent(object):
    """
    Attributes:
     - lie
     - tide
     - tire
     - tie
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'lie', (LIEPacket, LIEPacket.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'tide', (TIDEPacket, TIDEPacket.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'tire', (TIREPacket, TIREPacket.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'tie', (TIEPacket, TIEPacket.thrift_spec), None, ),  # 4
    )

    def __init__(self, lie=None, tide=None, tire=None, tie=None,):
        self.lie = lie
        self.tide = tide
        self.tire = tire
        self.tie = tie

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.lie = LIEPacket()
                    self.lie.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.tide = TIDEPacket()
                    self.tide.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.tire = TIREPacket()
                    self.tire.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.tie = TIEPacket()
                    self.tie.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('PacketContent')
        if self.lie is not None:
            oprot.writeFieldBegin('lie', TType.STRUCT, 1)
            self.lie.write(oprot)
            oprot.writeFieldEnd()
        if self.tide is not None:
            oprot.writeFieldBegin('tide', TType.STRUCT, 2)
            self.tide.write(oprot)
            oprot.writeFieldEnd()
        if self.tire is not None:
            oprot.writeFieldBegin('tire', TType.STRUCT, 3)
            self.tire.write(oprot)
            oprot.writeFieldEnd()
        if self.tie is not None:
            oprot.writeFieldBegin('tie', TType.STRUCT, 4)
            self.tie.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ProtocolPacket(object):
    """
    protocol packet structure

    Attributes:
     - header
     - content
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'header', (PacketHeader, PacketHeader.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'content', (PacketContent, PacketContent.thrift_spec), None, ),  # 2
    )

    def __init__(self, header=None, content=None,):
        self.header = header
        self.content = content

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = PacketHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.content = PacketContent()
                    self.content.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('ProtocolPacket')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.content is not None:
            oprot.writeFieldBegin('content', TType.STRUCT, 2)
            self.content.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.header is None:
            raise TProtocolException(message='Required field header is unset!')
        if self.content is None:
            raise TProtocolException(message='Required field content is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
